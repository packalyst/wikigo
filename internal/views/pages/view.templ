package pages

import (
	"fmt"
	"strings"
	"gowiki/internal/models"
	"gowiki/internal/views/layouts"
	"gowiki/internal/services"
)

type ViewData struct {
	layouts.PageData
	Page        *models.Page
	TOC         []services.TOCEntry
	Breadcrumbs []models.PageSummary
	Children    []models.PageSummary
}

func isEmptyContent(html string) bool {
	trimmed := strings.TrimSpace(html)
	return trimmed == "" || trimmed == "<p></p>" || trimmed == "<p> </p>"
}

templ View(data ViewData) {
	@layouts.Base(data.PageData) {
		<div class="page-header">
			<div class="page-header-top">
				<h1 class="page-title">{ data.Page.Title }</h1>
				if data.User != nil && data.User.Role.CanEdit() {
					<div class="page-actions btn-group">
						<a href={ templ.SafeURL("/edit/" + data.Page.Slug) } class="icon-btn" title="Edit page">
							<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/>
							</svg>
						</a>
						<a href={ templ.SafeURL("/history/" + data.Page.Slug) } class="icon-btn" title="View history">
							<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/>
							</svg>
						</a>
					</div>
				}
			</div>
			<div class="page-meta">
				<span class="page-meta-item">
					<svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"/>
					</svg>
					if data.Page.Author != nil {
						{ data.Page.Author.Username }
					} else {
						Unknown
					}
				</span>
				<span class="page-meta-separator"></span>
				<span class="page-meta-item">
					<svg width="14" height="14" fill="none" stroke="currentColor" viewBox="0 0 24 24">
						<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/>
					</svg>
					{ formatTime(data.Page.UpdatedAt) }
				</span>
				if len(data.Page.Tags) > 0 {
					<span class="page-meta-separator"></span>
					<span class="page-meta-tags">
						for _, tag := range data.Page.Tags {
							<a href={ templ.SafeURL("/tag/" + tag.Name) } class="tag tag-sm">{ tag.Name }</a>
						}
					</span>
				}
			</div>
		</div>

		<!-- Page content -->
		<div class="page-content">
			if isEmptyContent(data.Page.ContentHTML) && len(data.Children) > 0 {
				<!-- Category page: show children as grid like pages list -->
				<div class="page-grid">
					for _, child := range data.Children {
						<a href={ templ.SafeURL("/wiki/" + child.Slug) } class="page-card">
							<div class="page-card-title">
								<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
									<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
								</svg>
								{ child.Title }
							</div>
							if child.Excerpt != "" {
								<div class="page-card-desc">{ child.Excerpt }</div>
							}
						</a>
					}
				</div>
			} else {
				<div class="prose">
					@templ.Raw(data.Page.ContentHTML)
				</div>

				if len(data.Children) > 0 {
					<div class="child-pages">
						<h3 class="child-pages-title">
							<svg width="16" height="16" fill="none" stroke="currentColor" viewBox="0 0 24 24">
								<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
							</svg>
							Child Pages
						</h3>
						<div class="child-pages-grid">
							for _, child := range data.Children {
								<a href={ templ.SafeURL("/wiki/" + child.Slug) } class="child-page-card">
									<span class="child-page-title">{ child.Title }</span>
								</a>
							}
						</div>
					</div>
				}
			}
		</div>

		<!-- TOC highlight script -->
		<script>
			(function() {
				const tocLinks = document.querySelectorAll('.sidebar-toc-link');
				if (!tocLinks.length) return;

				const headings = [];
				tocLinks.forEach(link => {
					const id = link.getAttribute('data-target');
					const heading = document.getElementById(id);
					if (heading) headings.push({ id, el: heading, link });
				});

				function updateActiveLink() {
					const scrollPos = window.scrollY + 100;
					let activeIdx = 0;

					for (let i = 0; i < headings.length; i++) {
						if (headings[i].el.offsetTop <= scrollPos) {
							activeIdx = i;
						}
					}

					tocLinks.forEach(link => link.classList.remove('active'));
					if (headings[activeIdx]) {
						headings[activeIdx].link.classList.add('active');
					}
				}

				// Handle click navigation with smooth scroll
				tocLinks.forEach(link => {
					link.addEventListener('click', function(e) {
						e.preventDefault();
						const id = this.getAttribute('data-target');
						const target = document.getElementById(id);
						if (target) {
							target.scrollIntoView({ behavior: 'smooth', block: 'start' });
							history.pushState(null, '', '#' + id);
						}
						tocLinks.forEach(l => l.classList.remove('active'));
						this.classList.add('active');
					});
				});

				window.addEventListener('scroll', updateActiveLink, { passive: true });
				updateActiveLink();
			})();
		</script>
	}
}

func formatTime(t interface{}) string {
	if tm, ok := t.(interface{ Format(string) string }); ok {
		return tm.Format("Jan 2, 2006")
	}
	return ""
}

func tocIndent(level int) string {
	return fmt.Sprintf("%dpx", (level-1)*12)
}
